"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkbabylonjs"] = self["webpackChunkbabylonjs"] || []).push([["src_core_Turret_ts"],{

/***/ "./src/core/Projectile.ts":
/*!********************************!*\
  !*** ./src/core/Projectile.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Projectile: () => (/* binding */ Projectile)\n/* harmony export */ });\n/* harmony import */ var _ModelLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelLoader */ \"./src/core/ModelLoader.ts\");\n\nclass Projectile {\n    constructor(scene, position, targetMesh, speed) {\n        this.damageValue = 5; // Dégâts du projectile\n        this.scene = scene;\n        this.targetMesh = targetMesh;\n        this.speed = speed; // Initialize speed\n        // Vérifier si la physique est activée dans la scène\n        if (!scene.isPhysicsEnabled()) {\n            console.warn(\"⚠️ La physique n'est pas activée dans la scène. Activation en cours...\");\n            scene.enablePhysics(new BABYLON.Vector3(0, 0, 0), new BABYLON.CannonJSPlugin());\n        }\n        // Charger le modèle de l'étoile comme projectile\n        _ModelLoader__WEBPACK_IMPORTED_MODULE_0__.ModelLoader.loadModel(scene, \"star_yellow\", (result) => {\n            this.mesh = result.meshes[0]; // Use the first mesh from the loaded model\n            this.mesh.position = position;\n            this.mesh.scaling = new BABYLON.Vector3(3, 3, 3); // Adjust scale as needed\n            // Activer la physique pour le projectile\n            this.mesh.physicsImpostor = new BABYLON.PhysicsImpostor(this.mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.1 }, scene);\n            this.addParticleEffect(); // Ajouter les particules au projectile\n            this.moveToTarget();\n        });\n    }\n    addParticleEffect() {\n        const particleSystem = new BABYLON.ParticleSystem(\"projectileTrail\", 200, this.scene);\n        particleSystem.particleTexture = new BABYLON.Texture(\"textures/flare.png\", this.scene);\n        particleSystem.emitter = this.mesh; // Émettre depuis le projectile\n        particleSystem.minEmitBox = new BABYLON.Vector3(-0.1, -0.1, -0.1); // Zone d'émission minimale\n        particleSystem.maxEmitBox = new BABYLON.Vector3(0.1, 0.1, 0.1); // Zone d'émission maximale\n        particleSystem.color1 = new BABYLON.Color4(1, 1, 0, 1); // Jaune\n        particleSystem.color2 = new BABYLON.Color4(1, 0.5, 0, 1); // Orange\n        particleSystem.minSize = 0.1;\n        particleSystem.maxSize = 0.3;\n        particleSystem.minLifeTime = 0.2;\n        particleSystem.maxLifeTime = 0.5;\n        particleSystem.emitRate = 100;\n        particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;\n        particleSystem.gravity = new BABYLON.Vector3(0, 0, 0); // Pas de gravité pour les particules\n        particleSystem.direction1 = new BABYLON.Vector3(-0.5, -0.5, -0.5);\n        particleSystem.direction2 = new BABYLON.Vector3(0.5, 0.5, 0.5);\n        particleSystem.minEmitPower = 1;\n        particleSystem.maxEmitPower = 2;\n        particleSystem.updateSpeed = 0.01;\n        particleSystem.start();\n        // Stocker le système de particules pour le supprimer plus tard\n        this.mesh.metadata = Object.assign(Object.assign({}, this.mesh.metadata), { particleSystem });\n    }\n    moveToTarget() {\n        if (!this.targetMesh)\n            return;\n        let randomPhase = true; // Phase initiale d'étoile filante\n        const randomDuration = 1000; // Durée en ms pour le mouvement initial\n        const startTime = Date.now();\n        let zigzagDirection = 1; // Direction du zigzag (1 ou -1)\n        this.scene.onBeforeRenderObservable.add(() => {\n            if (!this.mesh || !this.mesh.physicsImpostor)\n                return;\n            // Ajouter une rotation continue au projectile\n            this.mesh.rotation.x += 0.05; // Rotation sur l'axe X\n            this.mesh.rotation.y += 0.05; // Rotation sur l'axe Y\n            if (randomPhase) {\n                // Mouvement en étoile filante avec zigzag\n                const timeElapsed = Date.now() - startTime;\n                const zigzagFrequency = 0.1; // Fréquence du zigzag\n                const zigzagAmplitude = 0.5; // Amplitude du zigzag\n                const zigzagOffset = Math.sin(timeElapsed * zigzagFrequency) * zigzagAmplitude * zigzagDirection;\n                const randomDirection = new BABYLON.Vector3(zigzagOffset, // Oscillation sur l'axe X\n                1, // Vers le haut\n                Math.random() * 0.5 - 0.25 // Légère variation sur l'axe Z\n                ).normalize();\n                const randomVelocity = randomDirection.scale(this.speed * 0.7); // Vitesse ajustée pour l'effet\n                this.mesh.physicsImpostor.setLinearVelocity(randomVelocity);\n                // Vérifier si la durée de l'effet étoile filante est écoulée\n                if (timeElapsed > randomDuration) {\n                    randomPhase = false; // Passer à la phase de ciblage\n                }\n            }\n            else if (this.targetMesh) {\n                // Mouvement vers la cible\n                const direction = this.targetMesh.position.subtract(this.mesh.position).normalize();\n                const velocity = direction.scale(this.speed);\n                this.mesh.physicsImpostor.setLinearVelocity(velocity);\n                const distance = BABYLON.Vector3.Distance(this.mesh.position, this.targetMesh.position);\n                if (distance <= 0.5) { // Threshold for hitting the target\n                    this.hitTarget();\n                }\n            }\n        });\n    }\n    hitTarget() {\n        var _a, _b;\n        console.log(\"🎯 Projectile a touché la cible !\");\n        this.createHitEffect(); // Add particle effect on hit\n        // Vérifier si le mesh a un `enemyInstance`\n        if ((_b = (_a = this.targetMesh) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.enemyInstance) {\n            let enemy = this.targetMesh.metadata.enemyInstance;\n            enemy.damage(this.damageValue); // ✅ Appelle `damage()` sur l'ennemi\n            if (enemy.health <= 0) { // Check if the enemy is dead\n                this.createDeathEffect(enemy.mesh.position); // Add particle effect on enemy death\n            }\n        }\n        this.dispose();\n    }\n    createHitEffect() {\n        const particleSystem = new BABYLON.ParticleSystem(\"hitEffect\", 100, this.scene);\n        particleSystem.particleTexture = new BABYLON.Texture(\"textures/flare.png\", this.scene);\n        particleSystem.emitter = this.mesh.position.clone(); // Emit from the projectile's position\n        particleSystem.minEmitBox = new BABYLON.Vector3(-0.1, -0.1, -0.1); // Emit in a small area\n        particleSystem.maxEmitBox = new BABYLON.Vector3(0.1, 0.1, 0.1);\n        particleSystem.color1 = new BABYLON.Color4(1, 1, 0, 1); // Yellow\n        particleSystem.color2 = new BABYLON.Color4(1, 0.5, 0, 1); // Orange\n        particleSystem.minSize = 0.1;\n        particleSystem.maxSize = 0.3;\n        particleSystem.minLifeTime = 0.2;\n        particleSystem.maxLifeTime = 0.5;\n        particleSystem.emitRate = 50;\n        particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;\n        particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);\n        particleSystem.direction1 = new BABYLON.Vector3(-1, -1, -1);\n        particleSystem.direction2 = new BABYLON.Vector3(1, 1, 1);\n        particleSystem.minEmitPower = 1;\n        particleSystem.maxEmitPower = 3;\n        particleSystem.updateSpeed = 0.01;\n        particleSystem.start();\n        setTimeout(() => particleSystem.dispose(), 500); // Dispose after 500ms\n    }\n    createDeathEffect(position) {\n        const particleSystem = new BABYLON.ParticleSystem(\"deathEffect\", 200, this.scene);\n        particleSystem.particleTexture = new BABYLON.Texture(\"particles/28.png\", this.scene);\n        particleSystem.emitter = position; // Emit from the enemy's position\n        particleSystem.minEmitBox = new BABYLON.Vector3(-0.5, -0.5, -0.5);\n        particleSystem.maxEmitBox = new BABYLON.Vector3(0.5, 0.5, 0.5);\n        particleSystem.color1 = new BABYLON.Color4(1, 0, 0, 1); // Red\n        particleSystem.color2 = new BABYLON.Color4(1, 0.5, 0, 1); // Orange\n        particleSystem.minSize = 0.2;\n        particleSystem.maxSize = 0.5;\n        particleSystem.minLifeTime = 0.5;\n        particleSystem.maxLifeTime = 1;\n        particleSystem.emitRate = 100;\n        particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;\n        particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);\n        particleSystem.direction1 = new BABYLON.Vector3(-1, -1, -1);\n        particleSystem.direction2 = new BABYLON.Vector3(1, 1, 1);\n        particleSystem.minEmitPower = 2;\n        particleSystem.maxEmitPower = 5;\n        particleSystem.updateSpeed = 0.01;\n        particleSystem.start();\n        setTimeout(() => particleSystem.dispose(), 1000); // Dispose after 1 second\n    }\n    dispose() {\n        var _a, _b;\n        // Supprimer les particules associées\n        const particleSystem = (_a = this.mesh.metadata) === null || _a === void 0 ? void 0 : _a.particleSystem;\n        if (particleSystem) {\n            particleSystem.stop();\n            particleSystem.dispose();\n        }\n        (_b = this.mesh.physicsImpostor) === null || _b === void 0 ? void 0 : _b.dispose(); // Supprime la physique\n        this.mesh.dispose(); // Supprime le projectile\n    }\n}\n\n\n//# sourceURL=webpack://babylonjs/./src/core/Projectile.ts?");

/***/ }),

/***/ "./src/core/Turret.ts":
/*!****************************!*\
  !*** ./src/core/Turret.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Turret: () => (/* binding */ Turret)\n/* harmony export */ });\n/* harmony import */ var _GlobalState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GlobalState */ \"./src/core/GlobalState.ts\");\n/* harmony import */ var _Projectile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Projectile */ \"./src/core/Projectile.ts\");\n/* harmony import */ var _ModelLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ModelLoader */ \"./src/core/ModelLoader.ts\");\n\n\n\nclass Turret {\n    constructor(scene, position, range = 10, projectileSpeed = 30, fireRate = 1000) {\n        this.target = null;\n        this.lastShotTime = 0;\n        this.scene = scene;\n        this.range = range;\n        this.projectileSpeed = projectileSpeed; // Initialize projectile speed\n        this.fireRate = fireRate; // Initialize fire rate\n        _ModelLoader__WEBPACK_IMPORTED_MODULE_2__.ModelLoader.loadModel(scene, \"garden_tree_2\", (result) => {\n            this.mesh = result.meshes[0];\n            this.mesh.position = position;\n            this.mesh.scaling = new BABYLON.Vector3(2, 2, 2); // Adjust scale as needed\n            // Add sprite sheet animation\n            // const spriteManager = new BABYLON.SpriteManager(\"spriteManager\", \"pipo-mapeffect013a.png\", 1, { width: 400, height: 400 }, this.scene);\n            /*   const sprite = new BABYLON.Sprite(\"effect\", spriteManager);\n               sprite.position = new BABYLON.Vector3(position.x, position.y+3, position.z); // Position below the turret\n               sprite.playAnimation(0, 9, true, 100); // Play frames 0 to 15 in a loop with 100ms per frame\n               sprite.size = 20; // Adjust size as needed\n           */\n        });\n        // Vérifier les ennemis toutes les 500ms\n        setInterval(() => {\n            this.findTarget();\n        }, 500);\n    }\n    findTarget() {\n        this.target = null;\n        let closestDist = this.range;\n        _GlobalState__WEBPACK_IMPORTED_MODULE_0__.enemies.forEach(enemy => {\n            if (enemy.mesh) { // Ensure the enemy is valid\n                const distance = BABYLON.Vector3.Distance(this.mesh.position, enemy.mesh.position);\n                if (distance < closestDist) {\n                    closestDist = distance;\n                    this.target = enemy.mesh;\n                }\n            }\n        });\n        if (this.target) {\n            console.log(`Turret targeting enemy at ${this.target.position}`);\n            this.shoot();\n        }\n    }\n    shoot() {\n        const now = Date.now();\n        if (now - this.lastShotTime > this.fireRate) {\n            new _Projectile__WEBPACK_IMPORTED_MODULE_1__.Projectile(this.scene, this.mesh.position.clone(), this.target, this.projectileSpeed); // Pass projectile speed\n            this.lastShotTime = now;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://babylonjs/./src/core/Turret.ts?");

/***/ })

}]);
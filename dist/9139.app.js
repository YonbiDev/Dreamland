"use strict";(self.webpackChunkbabylonjs=self.webpackChunkbabylonjs||[]).push([[9139],{4423:(t,e,o)=>{o.d(e,{r:()=>a});var s=o(2851),i=o(4720);const n="cachedOperationValue",r="cachedExecutionId";class a extends s.e{constructor(t,e){super(e),this.value=this.registerDataOutput("value",t),this.isValid=this.registerDataOutput("isValid",i.RI)}_updateOutputs(t){const e=t._getExecutionVariable(this,r,-1),o=t._getExecutionVariable(this,n,null);if(null!=o&&e===t.executionId)this.isValid.setValue(!0,t),this.value.setValue(o,t);else try{const e=this._doOperation(t);if(null==e)return void this.isValid.setValue(!1,t);t._setExecutionVariable(this,n,e),t._setExecutionVariable(this,r,t.executionId),this.value.setValue(e,t),this.isValid.setValue(!0,t)}catch(e){this.isValid.setValue(!1,t)}}}},9139:(t,e,o)=>{o.r(e),o.d(e,{FlowGraphJsonPointerParserBlock:()=>c});var s=o(868),i=o(4720);const n=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class r{constructor(t,e){this.path=t,this.ownerBlock=e,this.templatedInputs=[];let o=n.exec(t);const r=new Set;for(;o;){const[,a]=o;if(r.has(a))throw new Error("Duplicate template variable detected.");r.add(a),this.templatedInputs.push(e.registerDataInput(a,i.x2,new s.P(0))),o=n.exec(t)}}getAccessor(t,e){let o=this.path;for(const t of this.templatedInputs){const s=t.getValue(e).value;if("number"!=typeof s||s<0)throw new Error("Invalid value for templated input.");o=o.replace(`{${t.name}}`,s.toString())}return t.convert(o)}}var a=o(6552),u=o(6041),l=o(4423);class c extends l.r{constructor(t){super(i.Vv,t),this.config=t,this.object=this.registerDataOutput("object",i.Vv),this.propertyName=this.registerDataOutput("propertyName",i.Vv),this.setterFunction=this.registerDataOutput("setFunction",i.Vv,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",i.Vv,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",i.Vv,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new r(t.jsonPointer,this)}_doOperation(t){const e=this.templateComponent.getAccessor(this.config.pathConverter,t),o=e.info.get(e.object),s=e.info.getTarget?.(e.object),i=e.info.getPropertyName?.[0](e.object);if(!s)throw new Error("Object is undefined");return this.object.setValue(s,t),i&&this.propertyName.setValue(i,t),o}_setPropertyValue(t,e,o,s){const i=this.templateComponent.getAccessor(this.config.pathConverter,s),n=i.info.type;n.startsWith("Color")&&(o=h(o,n)),i.info.set?.(o,i.object)}_getPropertyValue(t,e,o){const s=this.templateComponent.getAccessor(this.config.pathConverter,o);return s.info.get(s.object)}_getInterpolationAnimationPropertyInfo(t,e,o){const s=this.templateComponent.getAccessor(this.config.pathConverter,o);return(t,e,o,i)=>{const n=[],r=s.info.type;return r.startsWith("Color")&&(t=t.map((t=>({frame:t.frame,value:h(t.value,r)})))),s.info.interpolation?.forEach(((e,r)=>{const a=s.info.getPropertyName?.[r](s.object)||"Animation-interpolation-"+r;let u=t;o!==e.type&&(u=t.map((t=>({frame:t.frame,value:e.getValue(void 0,t.value.asArray?t.value.asArray():[t.value],0,1)}))));const l=e.buildAnimations(s.object,a,60,u);for(const t of l)i&&t.babylonAnimation.setEasingFunction(i),n.push(t.babylonAnimation)})),n}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function h(t,e){return t.getClassName().startsWith("Color")?t:"Color3"===e?new u.v9(t.x,t.y,t.z):"Color4"===e?new u.ov(t.x,t.y,t.z,t.w):t}(0,a.Y5)("FlowGraphJsonPointerParserBlock",c)}}]);